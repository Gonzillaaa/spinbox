# Redis integration for FastAPI
# Generated by Spinbox on Fri Jul 18 11:32:52 CEST 2025

import redis.asyncio as redis
import os
import json
from typing import Any, Optional, Union
from datetime import timedelta

# Connection configuration
REDIS_URL = os.getenv("REDIS_URL", "redis://localhost:6379/0")
REDIS_MAX_CONNECTIONS = int(os.getenv("REDIS_MAX_CONNECTIONS", "20"))
DEFAULT_TTL = int(os.getenv("REDIS_DEFAULT_TTL", "3600"))
KEY_PREFIX = os.getenv("REDIS_KEY_PREFIX", "test-multi-deps:")

class RedisClient:
    def __init__(self):
        self.redis: Optional[redis.Redis] = None
    
    async def connect(self):
        """Connect to Redis"""
        self.redis = redis.from_url(
            REDIS_URL,
            max_connections=REDIS_MAX_CONNECTIONS,
            decode_responses=True
        )
        await self.redis.ping()
        print("Connected to Redis")
    
    async def disconnect(self):
        """Disconnect from Redis"""
        if self.redis:
            await self.redis.close()
            print("Disconnected from Redis")
    
    def _make_key(self, key: str) -> str:
        """Add prefix to key"""
        return f"{KEY_PREFIX}{key}"
    
    async def get(self, key: str) -> Optional[str]:
        """Get value by key"""
        if not self.redis:
            return None
        return await self.redis.get(self._make_key(key))
    
    async def set(self, key: str, value: str, ttl: Optional[int] = None) -> bool:
        """Set value with optional TTL"""
        if not self.redis:
            return False
        ttl = ttl or DEFAULT_TTL
        return await self.redis.setex(self._make_key(key), ttl, value)
    
    async def delete(self, key: str) -> bool:
        """Delete key"""
        if not self.redis:
            return False
        result = await self.redis.delete(self._make_key(key))
        return result > 0
    
    async def exists(self, key: str) -> bool:
        """Check if key exists"""
        if not self.redis:
            return False
        result = await self.redis.exists(self._make_key(key))
        return result > 0
    
    async def expire(self, key: str, ttl: int) -> bool:
        """Set TTL for existing key"""
        if not self.redis:
            return False
        return await self.redis.expire(self._make_key(key), ttl)
    
    async def get_json(self, key: str) -> Optional[dict]:
        """Get JSON value"""
        value = await self.get(key)
        if value:
            try:
                return json.loads(value)
            except json.JSONDecodeError:
                return None
        return None
    
    async def set_json(self, key: str, value: dict, ttl: Optional[int] = None) -> bool:
        """Set JSON value"""
        try:
            json_str = json.dumps(value)
            return await self.set(key, json_str, ttl)
        except (TypeError, ValueError):
            return False

# Global Redis client instance
redis_client = RedisClient()

async def get_redis() -> RedisClient:
    """Dependency for FastAPI"""
    return redis_client

# Example usage in FastAPI:
#
# from fastapi import FastAPI, Depends
# from .redis_config import redis_client, get_redis
#
# app = FastAPI()
#
# @app.on_event("startup")
# async def startup_redis():
#     await redis_client.connect()
#
# @app.on_event("shutdown")
# async def shutdown_redis():
#     await redis_client.disconnect()
#
# @app.get("/cache/{key}")
# async def get_cache(key: str, redis: RedisClient = Depends(get_redis)):
#     value = await redis.get(key)
#     return {"key": key, "value": value}
